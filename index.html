<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>DiscordChats ‚Äî Wolfpac</title>
  <style>
    :root { --bg:#202225; --bg-2:#2f3136; --bg-3:#36393f; --text:#e5e7eb; --muted:#a3a6aa; --accent:#ed4245; --brand:#7289da; }
    * { box-sizing:border-box }
    html,body{ margin:0; width:100%; max-width:100%; background:var(--bg-3); color:var(--text); font:14px/1.45 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; -webkit-text-size-adjust:100%; overflow-x:hidden; }

    /* --- Prevent iOS zoom-on-focus --- */
    input, select, button, textarea { font-size:16px; }

    .layout { display:grid; grid-template-columns:380px 1fr; height:100vh; }
    .left { background:var(--bg-2); border-right:1px solid #1f2024; display:flex; flex-direction:column; overflow:auto; }
    .guild{ position:relative; height:120px; background:url("wolfpac.gif") center/cover no-repeat; border-bottom:1px solid #1f2024; overflow:hidden; }
    .guild::before{ content:""; position:absolute; inset:0; background:linear-gradient(0deg, rgba(0,0,0,.60), rgba(0,0,0,.35)); }
    .guild h1{ position:absolute; left:16px; bottom:12px; margin:0; font-size:22px; font-weight:800; letter-spacing:.4px; color:#fff; display:flex; align-items:center; gap:8px; text-shadow:0 2px 6px rgba(0,0,0,.65), 0 0 12px rgba(0,0,0,.35); }
    .cat { padding:10px 12px; font-weight:700; color:#cdd0d4; letter-spacing:.3px }

    .center { display:flex; flex-direction:column; height:100vh }
    .channel-header { padding:12px 16px; background:var(--bg-2); border-bottom:1px solid #1f2024; display:flex; align-items:center; gap:10px; font-weight:700; justify-content:space-between }
    .muted { color:var(--muted) }
    .feed { padding:14px 16px; overflow:auto }

    .row { display:flex; gap:12px; padding:10px 0; border-bottom:1px solid rgba(255,255,255,.04); align-items:flex-start; }
    .avatar { width:44px; height:44px; border-radius:50%; object-fit:cover; background:#111; flex:0 0 auto; }
    .name { font-weight:700 }
    .content { white-space:pre-wrap; margin-top:4px; overflow-wrap:anywhere; word-break:break-word; }

    /* Attachments */
    .att { margin-top:8px; display:flex; flex-wrap:wrap; gap:8px; max-width:100%; }
    .att img, .att video { display:block; height:auto; max-width:420px; border-radius:8px; border:1px solid rgba(255,255,255,.08) }
    
    .mention-pill {
      display:inline-flex;
      align-items:center;
      padding:0 4px;
      margin:0 1px;
      border-radius:3px;
      background:#3e3f64; /* background */
      color:#8f93b9;      /* text */
      font-weight:600;
      font-size: 13px;
    }
    
    /* Primary Discord-style button (login + Open Discord) */
    .discord-login-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;

      background: #5865F2;
      color: #fff;

      padding: 14px 22px;
      font-size: 16px;
      font-weight: 700;

      border: 0;
      border-radius: 12px;
      cursor: pointer;

      text-decoration: none;

      box-shadow: 0 4px 22px rgba(0,0,0,0.35);

      transition: opacity .2s, transform .15s, background .15s;
      width:100%;
      max-width:260px;
    }

    .discord-login-btn:hover {
      background: #4752C4;
      transform: translateY(-1px);
    }

    .discord-logo-img {
      width: 22px;
      height: 22px;
      filter: invert(1); /* make logo white */
    }

    /* Gold subscribe button */
    .sub-btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:14px 22px;
      font-size:16px;
      font-weight:700;
      border:0;
      border-radius:12px;
      cursor:pointer;
      text-decoration:none;
      box-shadow:0 4px 22px rgba(0,0,0,0.35);
      transition: opacity .2s, transform .15s, background .15s;
      background:#f5c542;
      color:#1b1405;
      width:100%;
      max-width:260px;
    }
    .sub-btn:hover {
      background:#e0ae35;
      transform:translateY(-1px);
    }

    /* Non-image/video file presentation */
    .file-pill {
      display:inline-flex; align-items:center; gap:8px;
      background:#22252a; color:#cfd3da; border:1px solid #16171a;
      border-radius:8px; padding:8px 10px; text-decoration:none;
      max-width:min(420px,100%); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .file-pill:hover { background:#262a30; border-color:#1b1f25 }

    .calendar { padding:10px 10px 14px; }
    .cal { background:#26282d; border:1px solid #1b1c20; border-radius:10px; width:100%; }
    .cal-head{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px; border-bottom:1px solid #1b1c20; flex-wrap:wrap; }
    .cal-side{ display:flex; align-items:center; gap:8px; }
    .cal-head button, .cal-head select{
      background:#1f2024; color:#d6d8dd; border:1px solid #16171a; border-radius:6px; padding:8px 10px; cursor:pointer; white-space:nowrap;
    }
    .cal-week{ display:grid; grid-template-columns:repeat(7,1fr); padding:6px 8px; color:#b7bac0; font-size:12px; letter-spacing:.3px; }
    .cal-grid{ display:grid; grid-template-columns:repeat(7, 1fr); gap:6px; padding:0 8px 10px 8px; }
    .day{ position:relative; aspect-ratio:1/1; border-radius:8px; display:flex; align-items:center; justify-content:center; font-weight:600; border:1px solid #1b1c20; background:#202226; color:#d5d8dc }
    .day.muted{ opacity:.45 }
    .day.has{ cursor:pointer; background:#23262b }
    .day.has:hover{ outline:2px solid #3a4a84 }
    .day.selected{ outline:2px solid var(--brand); box-shadow:0 0 0 2px rgba(114,137,218,.25) inset; }
    .dot{ position:absolute; bottom:6px; right:6px; width:8px; height:8px; border-radius:50%; background:#4ade80 }
    .count{ position:absolute; top:6px; right:6px; font-size:10px; color:#aeb4ba }

    .search{ margin:14px 10px 14px; padding:12px; background:#26282d; border:1px solid #1b1c20; border-radius:10px; }
    .search-title{ font-weight:800; letter-spacing:.3px; margin-bottom:8px; display:flex; align-items:center; gap:6px; }
    #search-form{ display:block }
    #search-input{
      width:100%;
      background:#1f2024; color:#e8eaed;
      border:1px solid #16171a; border-radius:8px; padding:12px;
      outline:none;
    }
    #search-input::placeholder{ color:#9aa0a6 }
    .search-input-wrap{
      display:flex;
      align-items:center;
      gap:6px;
      background:#1f2024;
      border:1px solid #16171a;
      border-radius:8px;
      padding:4px 6px;
    }
    .search-input-wrap input{
      flex:1;
      border:0;
      outline:none;
      background:transparent;
      color:#e8eaed;
      padding:6px 6px;
    }
    
    /* from: pill (Discord-ish) */
    .search-pill{
      display:inline-flex;
      align-items:center;
      padding:2px 8px;
      border-radius:6px;
      background:#3e3f64;
      color:#8f93b9;
      font-size:12px;
      font-weight:600;
      cursor:pointer;          /* <--- add this */
    }
    #search-more {
      display: none;  /* always hidden unless fallback */
    }
    
    /* suggestion dropdown */
    .from-suggest{
      list-style:none;
      margin:6px 0 0;
      padding:0;
      max-height:220px;
      overflow:auto;
      border-radius:8px;
      background:#202226;
      border:1px solid #16171a;
      display:none;
    }
    .from-suggest li{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      cursor:pointer;
    }
    .from-suggest li:hover{
      background:#262a30;
    }
    .from-suggest img{
      width:22px;
      height:22px;
      border-radius:50%;
    }
    .from-suggest span.name{
      font-weight:600;
    }
    .from-suggest span.meta{
      font-size:11px;
      color:#9aa0a6;
    }
    .hl{ background:#5f5345; color:#fff; border-radius:4px; padding:0 2px; }

    /* Header user chip */
    .userbar { display:flex; align-items:center; gap:10px; }
    .chip { display:inline-flex; align-items:center; gap:8px; background:#1f2024; border:1px solid #16171a; border-radius:999px; padding:6px 10px; }
    .chip img { width:22px; height:22px; border-radius:50%; }
    .btn { background:#1f2024; color:#e8eaed; border:1px solid #16171a; border-radius:8px; padding:8px 10px; cursor:pointer; }
    .btn:hover { background:#24262b; }

    /* Gate overlay */
    .gate {
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index:9999;
      padding:20px;
    }
    .gate-card {
      width:min(560px, 95vw); background:#26282d; border:1px solid #1b1c20; border-radius:14px; padding:18px;
      box-shadow:0 10px 30px rgba(0,0,0,.45);
    }
    .gate-title {
      text-align:center;
      width:100%;
      font-size:18px;
      font-weight:700;
      margin:0 0 4px;
    }
    
    .gate-sub {
      text-align:center;
      width:100%;
      font-size:14px;
      color:#cdd0d4;
      margin:0 0 18px;
    }
    
    .rowy { display:flex; gap:10px; flex-wrap:wrap; margin-top:18px; }

    .pill {
      flex:1;
      min-width:220px;
      padding:18px 14px 16px;
      background:#202226;
      border:1px solid #17191d;
      border-radius:12px;
      display:flex;
      flex-direction:column;
      align-items:center;
      text-align:center;
      gap:10px;
    }
    .pill h4 { margin:0 0 4px; }
    .pill p  { margin:0 0 6px; color:#b9bec6 }

    .pill .discord-login-btn,
    .pill .sub-btn {
      width:100%;
      max-width:260px;
    }

    /* Profile panel */
    .profile { position:fixed; right:14px; top:62px; width:320px; background:#26282d; border:1px solid #1b1c20; border-radius:12px; padding:12px; display:none; z-index:999; }
    .profile h3 { margin:0 0 8px; }
    .kvs { font-size:13px; color:#cdd0d4; }
    .kvs div { display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06); }
    .kvs div:last-child{ border-bottom:0; }
    .danger { background:#3a1d1d; border-color:#5a2323 }
    .danger:hover { background:#431f1f }

    /* --- Mobile tweaks --- */
    @media (max-width: 980px){
      .layout{ grid-template-columns:1fr; height:auto; }
      .left{ order:-1; }
      .avatar{ width:36px; height:36px; }
      .feed{ padding:12px; }
      .att, .feed{ overflow-x:hidden; }
      .att img, .att video{ max-width:100%; width:100%; }
      html, body { overflow-x:hidden; }
    }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="left">
      <div class="guild"><h1><span class="wolf">üê∫</span> Wolfpac</h1></div>
      <div class="cat">üê∫„ÉªChats</div>

      <!-- Mobile menu toggle -->
      <div class="search" style="margin-top:0;margin-bottom:10px;">
        <button id="menu-toggle" class="btn" style="width:100%;">‚â° Menu</button>
      </div>

      <div id="menu-panel">
        <div class="calendar">
          <div class="cal">
            <div class="cal-head">
              <div class="cal-side cal-left">
                <button id="prev">Prev</button>
                <select id="month"></select>
              </div>
              <div class="cal-side cal-right">
                <select id="year"></select>
                <button id="next">Next</button>
              </div>
            </div>
            <div class="cal-week">
              <div>SUN</div><div>MON</div><div>TUE</div><div>WED</div><div>THU</div><div>FRI</div><div>SAT</div>
            </div>
            <div id="cal-grid" class="cal-grid"></div>
          </div>
        </div>
        
        <div class="search">
          <div class="search-title">Search <span class="glass">üîç</span></div>
          <form id="search-form" action="javascript:;" novalidate autocomplete="off">
            <div class="search-input-wrap">
              <span id="from-pill" class="search-pill" style="display:none;"></span>
              <span id="mentions-pill" class="search-pill" style="display:none;"></span>
              <span id="hasimage-pill" class="search-pill" style="display:none;"></span>
              <span id="on-pill" class="search-pill" style="display:none;"></span>   <!-- NEW -->
              <input id="search-input" type="text" placeholder="Find Messages‚Ä¶" />
            </div>
          </form>
          <ul id="from-suggest" class="from-suggest"></ul>
          <div id="search-hint" class="muted" style="margin-top:6px; font-size:12px;"></div>
        </div>
    </aside>

    <main class="center">
      <div class="channel-header">
        <div>
          <span id="channel-title"># chat-archive</span>
          <span class="muted" id="count"></span>
        </div>
    
        <div class="userbar">
          <!-- USER CHIP (hidden until logged in) -->
          <div id="user-chip" class="chip" style="display:none;">
            <img id="user-avatar" src="https://cdn.discordapp.com/embed/avatars/0.png" alt="">
            <span id="user-name">User</span>
            <button id="profile-btn" class="btn">Profile</button>
            <button id="logout-btn" class="btn">Logout</button>
          </div>
        </div>
      </div>
    
      <div id="messages" class="feed">
        <div id="messages-inner"></div>
      
        <!-- Load more for search -->
        <div id="search-more" style="display:none; text-align:center; padding:12px 0 18px;">
          <button id="search-more-btn" class="btn">Load More</button>
        </div>
      </div>
    </main>


  <!-- Gate overlay -->
  <div id="gate" class="gate" role="dialog" aria-modal="true">
    <div class="gate-card">
      <div class="gate-title" id="gate-title">Welcome to DiscordChats</div>
      <div class="gate-sub" id="gate-sub">Please sign in to continue.</div>
      <div id="gate-content"></div>
    </div>
  </div>

  <!-- Profile panel -->
  <div id="profile" class="profile">
    <h3>Account</h3>
    <div class="kvs">
      <div><span>Status</span><strong id="kv-status">‚Äî</strong></div>
      <div><span>Subscription</span><strong id="kv-sub">‚Äî</strong></div>
      <div><span>Period End</span><strong id="kv-end">‚Äî</strong></div>
    </div>
    <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
      <button id="cancel-sub" class="btn danger">Cancel Subscription</button>
      <button id="close-prof" class="btn">Close</button>
    </div>
  </div>

<script>
const API_BASE = "https://api.discordchats.com/api";
const $ = (s) => document.querySelector(s);
const mentionCache = new Map();  // id -> name
let fromFilterUser = null;        // { id, name }
let mentionsFilterUser = null;    // { id, name }
let hasImageFilter = false;       // true when has:image is active
let onDateFilter = null;          // "YYYY-MM-DD" when on: is active
let fromSuggestTimer = null;
let currentSuggestKind = null;    // "from" | "mentions" | null
let currentDay = null;           // "YYYY-MM-DD" currently loaded in calendar view
let dayOffset = 0;               // how many messages we‚Äôve already fetched for that day
let dayLoadedCount = 0;          // how many we‚Äôve rendered so far
const DAY_PAGE_SIZE = 2000;      // matches backend default limit
let dayHasMore = false;          // whether backend might have more rows
let dayLoading = false;          // guard against double-loads

async function resolveMentionIds(ids) {
  if (!ids || !ids.length) return;
  const unique = [...new Set(ids)];
  const qs = new URLSearchParams({ ids: unique.join(",") });

  try {
    const res = await apiFetch(`/mentions?${qs.toString()}`);
    if (!res) return;

    Object.entries(res).forEach(([id, name]) => {
      mentionCache.set(id, name);
      document.querySelectorAll(`.mention-pill[data-uid="${id}"]`)
        .forEach(el => {
          el.textContent = "@" + name;
        });
    });
  } catch (e) {
    console.error("mention resolve failed", e);
  }
}

function contentWithMentions(text) {
  const frag = document.createDocumentFragment();
  if (!text) return frag;

  const mentionRe = /<@!?(\d+)>/g;
  let lastIndex = 0;
  const pending = new Set();

  while (true) {
    const match = mentionRe.exec(text);
    if (!match) break;

    const [full, id] = match;

    // Text before the mention
    if (match.index > lastIndex) {
      frag.append(document.createTextNode(text.slice(lastIndex, match.index)));
    }

    // Mention pill
    const span = document.createElement("span");
    span.className = "mention-pill";
    span.dataset.uid = id;
    const cached = mentionCache.get(id);
    span.textContent = "@" + (cached || id);  // temporary label
    frag.append(span);

    if (!cached) pending.add(id);

    lastIndex = match.index + full.length;
  }

  // Trailing text
  if (lastIndex < text.length) {
    frag.append(document.createTextNode(text.slice(lastIndex)));
  }

  // Kick off async resolution for any unknown IDs
  if (pending.size) {
    resolveMentionIds(Array.from(pending));
  }

  return frag;
}

function contentWithMentionsAndHighlight(text, query) {
  // First build the base fragment with mention pills
  const base = contentWithMentions(text || "");
  if (!query) return base;

  const q = query.toLowerCase();
  const outFrag = document.createDocumentFragment();

  function walk(node, parent) {
    if (node.nodeType === Node.TEXT_NODE) {
      const src = node.textContent || "";
      let i = 0;
      while (i < src.length) {
        const idx = src.toLowerCase().indexOf(q, i);
        if (idx === -1) {
          if (i < src.length) parent.append(document.createTextNode(src.slice(i)));
          break;
        }
        if (idx > i) parent.append(document.createTextNode(src.slice(i, idx)));
        const mark = document.createElement("span");
        mark.className = "hl";
        mark.textContent = src.slice(idx, idx + q.length);
        parent.append(mark);
        i = idx + q.length;
      }
      return;
    }

    if (node.nodeType === Node.ELEMENT_NODE) {
      // Keep mention pills as-is
      if (node.classList.contains("mention-pill")) {
        parent.append(node);
        return;
      }
      const clone = node.cloneNode(false);
      parent.append(clone);
      node.childNodes.forEach(child => walk(child, clone));
      return;
    }
  }

  base.childNodes.forEach(child => walk(child, outFrag));
  return outFrag;
}


/* banners */
function banner(msg, ok=true){
  const bar = document.createElement('div');
  bar.style.cssText = `background:${ok?'#165c2e':'#8b1d1d'};color:#fff;padding:10px 14px;font:14px/1.3 system-ui,Segoe UI,Roboto;border-bottom:1px solid #0003`;
  bar.textContent = msg;
  document.body.prepend(bar);
}

/* small helpers */
function qsParam(name){
  const p = new URLSearchParams(location.search); return p.get(name);
}

async function apiFetch(path, opts={}){
  const url = `${API_BASE}${path}`;
  const res = await fetch(url, { credentials:'include', ...opts });
  if (!res.ok) throw new Error(`${url} ‚Üí ${res.status}`);
  const ct = res.headers.get('content-type') || '';
  if (ct.includes('application/json')) return res.json();
  return res.text();
}

async function fetchJSON(path) {
  return apiFetch(path);
}

function paintName(el, c1) {
  let color = '#ed4245';
  if (c1 && typeof c1 === 'string') {
    const s = c1.trim();
    if (/^#(?:[0-9a-f]{3}){1,2}$/i.test(s)) color = s;
  }
  el.style.backgroundImage = el.style.webkitBackgroundClip = el.style.backgroundClip = '';
  el.style.color = color;
}

/* ============================
   Attachment helpers (robust)
============================ */
function makeFilePill(href, label) {
  const a = document.createElement('a');
  a.className = 'file-pill';
  a.target = '_blank';
  a.rel = 'noreferrer noopener';
  a.href = href;
  a.textContent = label || (href || '').split('/').pop() || 'Open file';
  return a;
}

function isImageLike(a) {
  const t = (a.type || a.content_type || "").toLowerCase();
  if (t.startsWith("image/")) return true;

  const url = (a.s3_url || a.url || a.proxy_url || "").split("?")[0];
  return /\.(png|jpe?g|gif|webp|bmp|avif)$/i.test(url);
}

function isVideoLike(a) {
  const t = (a.type || a.content_type || "").toLowerCase();
  if (t.startsWith("video/")) return true;

  const url = (a.s3_url || a.url || a.proxy_url || "").split("?")[0];
  return /\.(mp4|webm|mov)$/i.test(url);
}

function buildAttachmentEl(a) {
  // Prefer s3_url if present, then url
  const src = a.s3_url || a.url || "";
  const name = a.filename || (src.split("/").pop() || "file");
  if (!src) return null;

  if (isImageLike(a)) {
    const img = document.createElement("img");
    img.src = src;
    img.alt = name;
    img.loading = "lazy";
    img.decoding = "async";
    img.onerror = () => img.replaceWith(makeFilePill(src, name));
    return img;
  }

  if (isVideoLike(a)) {
    const v = document.createElement("video");
    v.controls = true;
    v.playsInline = true;
    v.src = src;
    v.onerror = () => v.replaceWith(makeFilePill(src, name));
    return v;
  }

  return makeFilePill(src, name);
}


/* Message rows */
function messageRow(m) {
  const row = document.createElement('div'); row.className='row';
  const av = document.createElement('img'); av.className='avatar';
  av.src = m.avatar_url || 'https://cdn.discordapp.com/embed/avatars/0.png';
  const body = document.createElement('div'); body.style.flex='1';

  const head = document.createElement('div'); head.style.cssText='display:flex;align-items:center;gap:8px';
  const name = document.createElement('span'); name.className='name'; name.textContent = m.display_name || 'Unknown';
  paintName(name, m.role_color_1);
  const wolf = document.createElement('span'); wolf.textContent='üê∫';
  const time = document.createElement('span'); time.className='muted'; time.style.fontSize='12px'; time.textContent = m.time || m.ts_local_time || '';
  head.append(name, wolf, time);

  const content = document.createElement('div');
  content.className = 'content';
  content.textContent = '';
  if (m.content) {
    content.append(contentWithMentions(m.content));
  }

  const attWrap = document.createElement('div'); attWrap.className='att';
  if (Array.isArray(m.attachments)) {
    for (const a of m.attachments) {
      const el = buildAttachmentEl(a || {});
      if (el) attWrap.append(el);
    }
  }
  body.append(head, content, attWrap);
  row.append(av, body);
  return row;
}

/* ---------- Calendar state ---------- */
let avail = new Map();
let months = new Set();
let curY, curM;
let selectedDay = null;

function fillMonthYearRanges() {
  const mo = $('#month'), yr = $('#year');
  const names = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  mo.innerHTML = names.map((n,i)=>`<option value="${i}">${n}</option>`).join('');
  const years = [...months].map(s=>+s.split('-')[0]);
  const ymin = Math.min(...years), ymax = Math.max(...years);
  let yopt = '';
  for (let y=ymin; y<=ymax; y++) yopt += `<option value="${y}">${y}</option>`;
  yr.innerHTML = yopt;
}

function renderCalendar() {
  $('#month').value = String(curM);
  $('#year').value = String(curY);

  const grid = $('#cal-grid'); grid.innerHTML = '';
  const first = new Date(curY, curM, 1);
  const startDay = first.getDay();
  const daysInMonth = new Date(curY, curM+1, 0).getDate();

  const prevDays = startDay;
  const totalCells = 42;
  const prevMonthDays = new Date(curY, curM, 0).getDate();

  const cells = [];
  for (let i=prevDays-1; i>=0; i--) {
    const d = prevMonthDays - i;
    const date = new Date(curY, curM-1, d);
    cells.push({date, inMonth:false});
  }
  for (let d=1; d<=daysInMonth; d++) {
    cells.push({date:new Date(curY, curM, d), inMonth:true});
  }
  while (cells.length < totalCells) {
    const idx = cells.length - (prevDays + daysInMonth) + 1;
    cells.push({date:new Date(curY, curM+1, idx), inMonth:false});
  }

  for (const c of cells) {
    const yyyy = c.date.getFullYear();
    const mm = String(c.date.getMonth()+1).padStart(2,'0');
    const dd = String(c.date.getDate()).padStart(2,'0');
    const key = `${yyyy}-${mm}-${dd}`;
    const day = document.createElement('div');
    day.className = 'day' + (c.inMonth ? '' : ' muted');
    const count = avail.get(key);
    if (count && c.inMonth) {
      day.classList.add('has');
      day.title = `${count.toLocaleString()} messages`;
      const badge = document.createElement('div'); badge.className='dot'; day.append(badge);
      const cnt = document.createElement('div'); cnt.className='count'; cnt.textContent = count>999 ? '999+' : String(count); day.append(cnt);
      day.addEventListener('click', async () => {
        selectedDay = key;
        [...grid.children].forEach(el => el.classList.remove('selected'));
        day.classList.add('selected');
        await loadMessages(key);
        window.scrollTo({ top: 0, left: 0, behavior: 'instant' });
      });
      if (selectedDay === key) day.classList.add('selected');
    }
    day.textContent = c.date.getDate();
    grid.append(day);
  }
}

$('#prev').addEventListener('click', () => {
  if (curM === 0) { curM=11; curY--; } else { curM--; }
  renderCalendar();
});
$('#next').addEventListener('click', () => {
  if (curM === 11) { curM=0; curY++; } else { curM++; }
  renderCalendar();
});
$('#month').addEventListener('change', e => { curM = +e.target.value; renderCalendar(); });
$('#year').addEventListener('change', e => { curY = +e.target.value; renderCalendar(); });

async function loadDates() {
  try {
    const dates = await fetchJSON('/dates');   // [{date, count}]
    avail.clear(); months.clear();
    for (const d of dates) {
      const day = d.date || d.ts_local_date || d;
      avail.set(day, d.count ?? 0);
      months.add(day.slice(0,7));
    }
    fillMonthYearRanges();
    const latest = [...avail.keys()].sort().pop();
    selectedDay = latest;
    const [y,m] = latest.split('-');
    curY = +y; curM = +m - 1;
    renderCalendar();
    await loadMessages(latest);
  } catch (e) {
    console.error(e); banner('Failed to load dates.', false);
  }
}

async function loadMessages(dateStr) {
  try {
    searchMode = false;

    // reset day pagination state
    currentDay = dateStr;
    dayOffset = 0;
    dayLoadedCount = 0;
    dayHasMore = true;
    dayLoading = false;

    document.getElementById('search-more').style.display = 'none';
    document.getElementById('channel-title').textContent = `# chat-archive ‚Äî ${dateStr}`;

    const wrap = document.getElementById('messages');
    const inner = document.getElementById('messages-inner') || wrap;

    inner.innerHTML = '';

    const params = new URLSearchParams({
      date: dateStr,
      limit: String(DAY_PAGE_SIZE),
      offset: String(dayOffset),
    });

    const msgs = await fetchJSON(`/messages?${params.toString()}`);

    for (const m of msgs) inner.append(messageRow(m));

    dayLoadedCount = msgs.length;
    dayOffset += msgs.length;
    dayHasMore = (msgs.length === DAY_PAGE_SIZE);

    document.getElementById('count').textContent =
      dayLoadedCount ? `(${dayLoadedCount.toLocaleString()} msgs)` : '(0 msgs)';

    if (!msgs.length) {
      inner.innerHTML = '<div class="muted">No messages for this day.</div>';
      dayHasMore = false;
    }

    // Scroll back to top of the feed
    const feed = document.getElementById('messages');
    if (feed) feed.scrollTop = 0;
  } catch (e) {
    console.error(e);
    banner('Failed to load messages.', false);
  }
}

async function loadMoreDayMessages() {
  if (!currentDay || !dayHasMore || dayLoading || searchMode) return;

  const dayAtStart = currentDay;   // üß† capture the day this load is for
  dayLoading = true;

  try {
    const inner = document.getElementById('messages-inner') || document.getElementById('messages');

    const params = new URLSearchParams({
      date: dayAtStart,
      limit: String(DAY_PAGE_SIZE),
      offset: String(dayOffset),
    });

    const msgs = await fetchJSON(`/messages?${params.toString()}`);

    // If user clicked a different day while this was loading, drop these results
    if (dayAtStart !== currentDay) {
      return;
    }

    let added = 0;
    for (const m of msgs) {
      inner.append(messageRow(m));
      added++;
    }

    dayLoadedCount += added;
    dayOffset += msgs.length;

    const totalForDay = avail.get(currentDay);
    document.getElementById('count').textContent =
      typeof totalForDay === 'number'
        ? `(${totalForDay.toLocaleString()} msgs)`
        : (dayLoadedCount ? `(${dayLoadedCount.toLocaleString()} msgs)` : '(0 msgs)');

    if (msgs.length < DAY_PAGE_SIZE) {
      dayHasMore = false;
    }
  } catch (e) {
    console.error(e);
    banner('Failed to load more messages.', false);
    dayHasMore = false;
  } finally {
    // Only clear the flag if we're still on the same day
    if (dayAtStart === currentDay) {
      dayLoading = false;
    }
  }
}

/* ---------- Search (newest ‚Üí oldest handled server-side) ---------- */
let currentSearch = "";
let searchMode = false;       // are we viewing search results vs calendar?
let searchLimit = 200;
let searchOffset = 0;         // how many rows we've already fetched
let searchShownCount = 0;     // how many rows we've shown so far
async function fetchSearch(q, limit=1000, offset=0){
  const params = new URLSearchParams({ q, limit, offset });
  if (fromFilterUser && fromFilterUser.id) {
    params.append('user_id', String(fromFilterUser.id));
  }
  if (mentionsFilterUser && mentionsFilterUser.id) {
    params.append('mentioned_id', String(mentionsFilterUser.id));
  }
  if (hasImageFilter) {
    // backend can use this to only return messages that have image attachments
    params.append('has_image', '1');
  }
  if (onDateFilter) {
    params.append('on_date', onDateFilter);   // <-- send date to backend
  }

  const url = `${API_BASE}/search?` + params.toString();
  const res = await fetch(url, { credentials:'include' });
  if (!res.ok) throw new Error(`/search ${res.status}`);
  return res.json();
}

function updateFilterPills(){
  const fromPill = document.getElementById('from-pill');
  const mentionPill = document.getElementById('mentions-pill');
  const hasImagePill = document.getElementById('hasimage-pill');
  const onPill = document.getElementById('on-pill');            // NEW

  if (fromFilterUser){
    fromPill.style.display = 'inline-flex';
    fromPill.textContent = `from: ${fromFilterUser.name}`;
  } else {
    fromPill.style.display = 'none';
  }

  if (mentionsFilterUser){
    mentionPill.style.display = 'inline-flex';
    mentionPill.textContent = `mentions: ${mentionsFilterUser.name}`;
  } else {
    mentionPill.style.display = 'none';
  }

  if (hasImageFilter){
    hasImagePill.style.display = 'inline-flex';
    hasImagePill.textContent = 'has:image';
  } else {
    hasImagePill.style.display = 'none';
  }

  if (onDateFilter){                                           
    onPill.style.display = 'inline-flex';
    onPill.textContent = `on: ${onDateFilter}`;
  } else {
    onPill.style.display = 'none';
  }
}

function clearFromFilter(runSearch = true) {
  fromFilterUser = null;
  updateFilterPills();
  if (runSearch) doSearch();
}

function clearMentionsFilter(runSearch = true) {
  mentionsFilterUser = null;
  updateFilterPills();
  if (runSearch) doSearch();
}

function clearHasImageFilter(runSearch = true) {
  hasImageFilter = false;
  updateFilterPills();
  if (runSearch) doSearch();
}

function clearOnFilter(runSearch = true) {
  onDateFilter = null;
  updateFilterPills();
  if (runSearch) doSearch();
}

async function fetchUserSuggestions(term){
  const res = await apiFetch(`/users?` + new URLSearchParams({ term, limit: 20 }));
  return res; // array of {user_id, display_name, avatar_url, messages}
}

function showFromSuggestions(list){
  const ul = document.getElementById('from-suggest');
  ul.innerHTML = '';
  if (!list || !list.length){
    ul.style.display = 'none';
    return;
  }
  for (const u of list){
    const li = document.createElement('li');
    const img = document.createElement('img');
    img.src = u.avatar_url || 'https://cdn.discordapp.com/embed/avatars/0.png';

    const name = document.createElement('span');
    name.className = 'name';
    name.textContent = u.display_name || `User ${u.user_id}`;

    const meta = document.createElement('span');
    meta.className = 'meta';
    meta.textContent = `${u.messages.toLocaleString()} msgs`;

    li.append(img, name, meta);

    li.onclick = () => {
      if (currentSuggestKind === 'from') {
        fromFilterUser = { id: u.user_id, name: name.textContent };
      } else if (currentSuggestKind === 'mentions') {
        mentionsFilterUser = { id: u.user_id, name: name.textContent };
      }
      updateFilterPills();

      document.getElementById('from-suggest').style.display = 'none';
      const inp = document.getElementById('search-input');
      inp.value = '';  // clear out the `from:` / `mentions:` text
      inp.focus();
      currentSuggestKind = null;
    };

    ul.append(li);
  }
  ul.style.display = 'block';
}


function setContentWithHighlight(containerEl, text, query){
  containerEl.textContent = "";
  if (!query){ containerEl.textContent = text || ""; return; }
  const q = query.toLowerCase();
  let i = 0; const src = text || "";
  while (i < src.length){
    const idx = src.toLowerCase().indexOf(q, i);
    if (idx === -1){ containerEl.append(document.createTextNode(src.slice(i))); break; }
    if (idx > i) containerEl.append(document.createTextNode(src.slice(i, idx)));
    const mark = document.createElement("span"); mark.className = "hl"; mark.textContent = src.slice(idx, idx + q.length);
    containerEl.append(mark); i = idx + q.length;
  }
}

function messageRowWithHL(m, query){
  const row = document.createElement('div');
  row.className='row';

  const av = document.createElement('img');
  av.className='avatar';
  av.src = m.avatar_url || 'https://cdn.discordapp.com/embed/avatars/0.png';

  const body = document.createElement('div');
  body.style.flex='1';

  const head = document.createElement('div');
  head.style.cssText='display:flex;align-items:center;gap:8px';

  const name = document.createElement('span');
  name.className='name';
  name.textContent = m.display_name || 'Unknown';
  paintName(name, m.role_color_1);

  const wolf = document.createElement('span');
  wolf.textContent='üê∫';

  const time = document.createElement('span');
  time.className='muted';
  time.style.fontSize='12px';
  time.textContent = (m.date ? `${m.date} ` : "") + (m.time || m.ts_local_time || '');

  head.append(name, wolf, time);

  // üëá mention-aware + highlight
  const content = document.createElement('div');
  content.className='content';

  const frag = contentWithMentionsAndHighlight(m.content || '', query);
  if (frag) content.append(frag);

  const attWrap = document.createElement('div');
  attWrap.className='att';
  if (Array.isArray(m.attachments)) {
    for (const a of m.attachments) {
      const el = buildAttachmentEl(a || {});
      if (el) attWrap.append(el);
    }
  }

  body.append(head, content, attWrap);
  row.append(av, body);
  return row;
}

async function doSearch(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }

  const input = document.getElementById('search-input');
  const q = (input.value || '').trim();

  // If there is no text AND no filters at all, don't do anything
  if (!q && !fromFilterUser && !mentionsFilterUser && !hasImageFilter && !onDateFilter) return;

  currentSearch = q;
  searchMode = true;
  searchOffset = 0;
  searchShownCount = 0;

  const titleBits = [];
  if (fromFilterUser)     titleBits.push(`from: ${fromFilterUser.name}`);
  if (mentionsFilterUser) titleBits.push(`mentions: ${mentionsFilterUser.name}`);
  if (hasImageFilter)     titleBits.push('has:image');
  if (onDateFilter)       titleBits.push(`on: ${onDateFilter}`);
  if (q)                  titleBits.push(`"${q}"`);

  document.getElementById('channel-title').textContent =
    '# search ‚Äî ' + (titleBits.length ? titleBits.join(' ¬∑ ') : 'results');

  document.getElementById('count').textContent = '';
  document.getElementById('search-hint').textContent = 'Searching‚Ä¶';

  try {
    const { ok, rows } = await fetchSearch(q, searchLimit, searchOffset);

    const wrap = document.getElementById('messages-inner');
    wrap.innerHTML = '';

    let shown = 0;
    for (const m of rows) {
      // still keep the client-side image check for has:image
      if (hasImageFilter) {
        const atts = Array.isArray(m.attachments) ? m.attachments : [];
        const hasImg = atts.some(a => isImageLike(a || {}));
        if (!hasImg) continue;
      }
      wrap.append(messageRowWithHL(m, q));
      shown++;
    }

    searchShownCount = shown;
    searchOffset += rows.length; // move offset by *rows returned*, not shown

    document.getElementById('count').textContent =
      shown ? `(${shown.toLocaleString()} results)` : '(0 results)';
    document.getElementById('search-hint').textContent =
      shown ? '' : 'No matches.';

    // Show or hide "Load more"
    const moreWrap = document.getElementById('search-more');
    if (rows.length === searchLimit) {
      moreWrap.style.display = 'block';
    } else {
      moreWrap.style.display = 'none';
    }

    window.scrollTo({ top: 0, left: 0, behavior: 'instant' });
  } catch (err) {
    console.error(err);
    banner('Search failed.', false);
    document.getElementById('search-hint').textContent = 'Search failed.';
    document.getElementById('search-more').style.display = 'none';
  }
}

async function loadMoreSearch() {
  if (!searchMode) return; // only valid while in search mode

  document.getElementById('search-hint').textContent = 'Loading more‚Ä¶';

  try {
    const { ok, rows } = await fetchSearch(currentSearch, searchLimit, searchOffset);

    const wrap = document.getElementById('messages-inner');
    let added = 0;

    for (const m of rows) {
      if (hasImageFilter) {
        const atts = Array.isArray(m.attachments) ? m.attachments : [];
        const hasImg = atts.some(a => isImageLike(a || {}));
        if (!hasImg) continue;
      }
      wrap.append(messageRowWithHL(m, currentSearch));
      added++;
    }

    searchShownCount += added;
    searchOffset += rows.length;

    document.getElementById('count').textContent =
      searchShownCount ? `(${searchShownCount.toLocaleString()} results)` : '(0 results)';
    document.getElementById('search-hint').textContent = '';

    // If we got a full page, assume there's more; otherwise hide the button
    const moreWrap = document.getElementById('search-more');
    if (rows.length === searchLimit) {
      moreWrap.style.display = 'block';
    } else {
      moreWrap.style.display = 'none';
    }
  } catch (err) {
    console.error(err);
    banner('Load more failed.', false);
    document.getElementById('search-hint').textContent = 'Load more failed.';
    document.getElementById('search-more').style.display = 'none';
  }
}

/* -------- Gate/UI logic -------- */
const gateEl = $('#gate');
const gateTitle = $('#gate-title');
const gateSub = $('#gate-sub');
const gateContent = $('#gate-content');

async function getGate(){
  try {
    return await apiFetch('/gate/status');
  } catch {
    return { authenticated:false, allowed:false, reason:'error' };
  }
}
async function getMe(){
  try {
    return await apiFetch('/me');
  } catch {
    return null;
  }
}

function showGate(contentBuilder){
  gateContent.innerHTML = '';
  contentBuilder && contentBuilder(gateContent);
  gateEl.style.display = 'flex';
}
function hideGate(){ gateEl.style.display = 'none'; }
  
async function startLogin(){
  try{
    const { url } = await apiFetch('/auth/login');
    location.href = url; // Discord OAuth
  }catch(e){ banner('Login init failed.', false); }
}
async function startCheckout(){
  try{
    const { url } = await apiFetch('/pay/checkout', { method:'POST' });
    location.href = url; // Stripe Checkout
  }catch(e){ banner('Checkout init failed.', false); }
}
async function doLogout(){
  try{
    await apiFetch('/auth/logout', { method:'POST' });
    $('#user-chip').style.display = 'none';
    const loginBtn = $('#login-btn');
    if (loginBtn) loginBtn.style.display = '';
    hideProfile();
    await bootGate(); // re-check with new flow
  }catch(e){ banner('Logout failed.', false); }
}

async function checkBoostThenMaybeOpenDiscord(btn) {
  if (btn) {
    btn.disabled = true;
    const labelSpan = btn.querySelector('span');
    if (labelSpan) labelSpan.textContent = 'Checking‚Ä¶';
  }

  try {
    const status = await getGate();  // calls /api/gate/status

    if (status && status.allowed) {
      // User is now a booster or paid ‚Üí rerun full gate boot
      await bootGate();
    } else {
      // Still not allowed ‚Üí send them to Discord to boost
      window.open('https://discord.com/app', '_blank', 'noopener,noreferrer');
    }
  } catch (e) {
    console.error('Boost check failed', e);
    // Fallback: still open Discord so they can at least get to the server
    window.open('https://discord.com/app', '_blank', 'noopener,noreferrer');
  } finally {
    if (btn) {
      btn.disabled = false;
      const labelSpan = btn.querySelector('span');
      if (labelSpan) labelSpan.textContent = "I've Boosted";
    }
  }
}

/* Not logged in gate */
function gateNotLoggedIn() {
  gateTitle.textContent = 'Welcome to DiscordChats';
  gateSub.textContent = 'Please sign in with Discord to continue.';

  showGate((wrap) => {
    const box = document.createElement('div');
    box.style.cssText = `
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      width:100%;
      padding:8px 0 0;
      gap:16px;
      text-align:center;
    `;

    const btn = document.createElement('button');
    btn.className = "discord-login-btn";
    btn.onclick = startLogin;
    btn.innerHTML = `
      <img class="discord-logo-img"
        src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/discord.svg"
        alt="Discord">
      <span>Sign in via Discord</span>
    `;

    box.append(btn);
    wrap.append(box);
  });
}

  
function gatePaywall(){
  gateTitle.textContent = 'Choose access';
  gateSub.textContent = 'Boosters are free. Otherwise subscribe for $5/month.';

  showGate((wrap)=>{
    const row = document.createElement('div'); 
    row.className='rowy';

    // Boost pill
    const a = document.createElement('div'); 
    a.className='pill';
    a.innerHTML = `<h4>Boost the Server</h4><p>Active Nitro boosters get free access.</p>`;

    const aBtn = document.createElement('button');
    aBtn.type = 'button';
    aBtn.className = 'discord-login-btn';
    aBtn.onclick = () => checkBoostThenMaybeOpenDiscord(aBtn);
    aBtn.innerHTML = `
      <img class="discord-logo-img"
        src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/discord.svg"
        alt="Discord">
      <span>I've Boosted</span>
    `;
    a.append(aBtn);

    // Subscribe pill
    const b = document.createElement('div'); 
    b.className='pill';
    b.innerHTML = `<h4>Subscribe</h4><p>Unlock the archive with a monthly sub.</p>`;

    const bBtn = document.createElement('button'); 
    bBtn.type = 'button';
    bBtn.className = 'sub-btn';
    bBtn.textContent = 'Subscribe';
    bBtn.onclick = startCheckout;
    b.append(bBtn);

    row.append(a,b); 
    wrap.append(row);

    // üîπ Opt-out line
    const opt = document.createElement('div');
    opt.style.cssText = `
      margin-top: 12px;
      text-align: center;
      font-size: 11px;
      color: #8b8f98;
      font-style: italic;
    `;
    opt.innerHTML = `
      to opt-out of discordchats click
      <span id="optout-link"
            style="cursor:pointer; text-decoration:underline; font-weight:600;">
        here
      </span>
    `;
    wrap.append(opt);

    const optLink = opt.querySelector('#optout-link');
    optLink.addEventListener('click', async (ev) => {
      ev.preventDefault();
      if (!confirm('This will hide your messages from the archive for other viewers. Continue?')) {
        return;
      }
      try {
        await apiFetch('/optout', { method: 'POST' });
        banner('You have opted out. Your messages will no longer be shown in the archive.', true);
      } catch (e) {
        console.error(e);
        banner('Opt-out failed. Please try again.', false);
      }
    });
  });
}

async function paintGate(){  // legacy helper (not used by boot, but kept just in case)
  const status = await getGate();
  if (!status.authenticated){
    const loginBtn = $('#login-btn');
    if (loginBtn) loginBtn.style.display = '';
    $('#user-chip').style.display = 'none';
    gateNotLoggedIn();
    return;
  }
  const loginBtn = $('#login-btn');
  if (loginBtn) loginBtn.style.display = 'none';

  const me = await getMe();
  if (me){
    $('#user-chip').style.display = 'inline-flex';
    $('#user-name').textContent = me.display_name || ('User ' + me.discord_user_id);
    $('#user-avatar').src = me.avatar_url || 'https://cdn.discordapp.com/embed/avatars/0.png';
    const isBooster = !!me.is_booster;
    const sub = me.subscription;
    const statusText = isBooster ? 'Booster' : (sub?.status || '‚Äî');
    const periodEnd = sub?.current_period_end ? new Date(sub.current_period_end).toLocaleString() : '‚Äî';
    $('#kv-status').textContent = statusText;
    $('#kv-sub').textContent = sub ? (sub.stripe_sub_id ? 'Stripe' : '‚Äî') : (isBooster ? 'Booster' : '‚Äî');
    $('#kv-end').textContent = periodEnd;
    $('#cancel-sub').style.display = (sub && (sub.status === 'active' || sub.status === 'trialing')) ? 'inline-block' : 'none';
  }
  if (!status.allowed){
    gatePaywall();
  } else {
    hideGate();
  }
}

/* Profile panel */
function toggleProfile(){
  const el = $('#profile');
  el.style.display = (el.style.display === 'block') ? 'none' : 'block';
}
function hideProfile(){ $('#profile').style.display = 'none'; }

/* Mobile menu collapse */
(function(){
  const panel = document.getElementById('menu-panel');
  const btn = document.getElementById('menu-toggle');
  const mq = window.matchMedia('(max-width: 980px)');
  function setInitial(){
    panel.style.display = 'block';
  }
  btn.addEventListener('click', ()=> {
    const vis = panel.style.display !== 'none';
    panel.style.display = vis ? 'none' : 'block';
  });
  mq.addEventListener?.('change', setInitial);
  setInitial();
})();

/* Boot */
window.addEventListener('DOMContentLoaded', async () => {

  // wire buttons
  $('#logout-btn').addEventListener('click', doLogout);
  $('#profile-btn').addEventListener('click', toggleProfile);
  $('#close-prof').addEventListener('click', hideProfile);
  $('#cancel-sub').addEventListener('click', async () => {
    if (!confirm('Cancel your subscription now? This will log you out.')) return;
    try {
      await apiFetch('/pay/cancel', { method:'POST' });
      banner('Subscription canceled.', true);
      await bootGate();
    } catch (e) {
      banner('Cancel failed.', false);
    }
  });

  // Stripe return messages
  if (qsParam('paid') === '1')
    banner('Thanks! Your subscription is active. If you just returned from Stripe, give it a few seconds.', true);

  if (qsParam('cancel') === '1')
    banner('Checkout canceled.', false);

  // Search box events
  const form = document.getElementById('search-form');
  if (form) {
    form.setAttribute('action', 'javascript:void(0)');
    form.noValidate = true;
    form.addEventListener('submit', doSearch);
  }

  const input = document.getElementById('search-input');
  if (input) {
    input.addEventListener('keydown', (e) => {
      // Backspace: when box is empty and we're NOT in the middle of typing "from:" or "mentions:",
      // pop the last pill (mentions ‚Üí from ‚Üí has:image)
      if (e.key === 'Backspace') {
        const value = e.target.value || '';
        if (!value && !currentSuggestKind) {
          const suggestList = document.getElementById('from-suggest');
          if (suggestList) suggestList.style.display = 'none';

          if (mentionsFilterUser) {
            clearMentionsFilter(true);  // also re-run search
            return;
          }
          if (fromFilterUser) {
            clearFromFilter(true);      // also re-run search
            return;
          }
          if (hasImageFilter) {
            clearHasImageFilter(true);  // also re-run search
            return;
          }
          if (onDateFilter) {               // NEW
            clearOnFilter(true);
            return;
          }
        }
      }

      if (e.key === 'Enter') {
        doSearch(e);
      }
    });

    input.addEventListener('input', (e) => {
      const suggestList = document.getElementById('from-suggest');
      let raw = e.target.value || '';
      let v   = raw.trimStart();

      // --- Handle has:image token anywhere in the raw string ---
      const lowerRaw = raw.toLowerCase();
      if (lowerRaw.includes('has:image')) {
        if (!hasImageFilter) {
          hasImageFilter = true;
          updateFilterPills();
        }
        // strip all occurrences of has:image from the visible input
        raw = raw.replace(/has:image/gi, '').replace(/\s+/g, ' ').trimStart();
        v = raw;
        e.target.value = raw;
      } else if (hasImageFilter && !lowerRaw.includes('has:image')) {
        // user manually removed the token from the text
        // (we do not auto-clear the filter here; they'll clear via pill/backspace)
      }

      const onMatch = raw.match(/\bon:\s*(\d{4}-\d{2}-\d{2})/i);
      if (onMatch) {
        const dateStr = onMatch[1];
        onDateFilter = dateStr;
        updateFilterPills();

        // strip just that on: token from the visible input
        raw = raw.replace(onMatch[0], '').replace(/\s+/g, ' ').trimStart();
        v = raw;
        e.target.value = raw;
      }

      // 1) If we don't have a token yet, see if the user just typed `from:` or `mentions:`
      if (!currentSuggestKind) {
        const lower = v.toLowerCase();

        if (lower.startsWith('from:')) {
          currentSuggestKind = 'from';

          // show a "from:" pill immediately
          const pill = document.getElementById('from-pill');
          pill.style.display = 'inline-flex';
          pill.textContent = 'from:';

          // strip "from:" out of the visible input so they just type the name
          v = v.slice('from:'.length).trimStart();
          e.target.value = v;
        } else if (lower.startsWith('mentions:')) {
          currentSuggestKind = 'mentions';

          const pill = document.getElementById('mentions-pill');
          pill.style.display = 'inline-flex';
          pill.textContent = 'mentions:';

          v = v.slice('mentions:'.length).trimStart();
          e.target.value = v;
        } else {
          // not starting a token ‚Üí no suggestions
          suggestList.style.display = 'none';
          return;
        }
      }

      // 2) We are in "from" or "mentions" mode: treat whatever is in the box as the user term
      const term = v.trim();
      if (!term) {
        suggestList.style.display = 'none';
        return;
      }

      clearTimeout(fromSuggestTimer);
      fromSuggestTimer = setTimeout(async () => {
        try {
          const list = await fetchUserSuggestions(term);
          showFromSuggestions(list);
        } catch (err) {
          console.error(err);
        }
      }, 200);
    });
  }

  // Allow clicking the pills themselves to clear the filter
  const fromPill = document.getElementById('from-pill');
  if (fromPill) {
    fromPill.addEventListener('click', () => {
      clearFromFilter(true); // also re-run search / restore calendar
    });
  }

  const mentionsPill = document.getElementById('mentions-pill');
  if (mentionsPill) {
    mentionsPill.addEventListener('click', () => {
      clearMentionsFilter(true);
    });
  }

  const hasImagePill = document.getElementById('hasimage-pill');
  if (hasImagePill) {
    hasImagePill.addEventListener('click', () => {
      clearHasImageFilter(true);
    });
  }

  const onPill = document.getElementById('on-pill');
  if (onPill) {
    onPill.addEventListener('click', () => {
      clearOnFilter(true);   // NEW
    });
  }

  const moreBtn = document.getElementById('search-more-btn');
  if (moreBtn) {
    moreBtn.addEventListener('click', () => {
      loadMoreSearch();
    });
  }

  // üî• Infinite scroll: auto-load more when feed is near bottom
  const feed = document.getElementById('messages');
  if (feed) {
    feed.addEventListener('scroll', () => {
      const nearBottom =
        feed.scrollTop + feed.clientHeight >= feed.scrollHeight - 300;
  
      if (!nearBottom) return;
  
      if (searchMode) {
        // search mode paging
        const moreWrap = document.getElementById('search-more');
        if (moreWrap && moreWrap.style.display === 'block') {
          moreWrap.style.display = 'none';
          loadMoreSearch();
        }
      } else {
        // calendar/day view paging
        loadMoreDayMessages();
      }
    });
  }

  // New secure boot process
  await bootGate();
});

/* -----------------------------------------------------
   SECURE GATE LOADING LOGIC (NEW)
----------------------------------------------------- */
async function bootGate() {

  const status = await getGate();

  // Not logged in
  if (!status.authenticated) {
    const loginBtn = $('#login-btn');
    if (loginBtn) loginBtn.style.display = '';
    $('#user-chip').style.display = 'none';
    gateNotLoggedIn();
    return; // do NOT load archive
  }

  // Logged in ‚Üí show chip
  const me = await getMe();
  if (me) {
    $('#user-chip').style.display = 'inline-flex';
    $('#user-name').textContent = me.display_name || ('User ' + me.discord_user_id);
    $('#user-avatar').src = me.avatar_url || 'https://cdn.discordapp.com/embed/avatars/0.png';

    const isBooster = !!me.is_booster;
    const sub = me.subscription;

    $('#kv-status').textContent = isBooster ? 'Booster' : (sub?.status || '‚Äî');
    $('#kv-sub').textContent = sub ? (sub.stripe_sub_id ? 'Stripe' : '‚Äî') : (isBooster ? 'Booster' : '‚Äî');
    $('#kv-end').textContent = sub?.current_period_end ?
      new Date(sub.current_period_end).toLocaleString() : '‚Äî';

    $('#cancel-sub').style.display =
      (sub && (sub.status === 'active' || sub.status === 'trialing'))
        ? 'inline-block'
        : 'none';
  }

  // Authenticated but NOT allowed
  if (!status.allowed) {
    gatePaywall();
    return; // do NOT load archive
  }

  // Allowed ‚Üí remove gate + load archive
  hideGate();
  await loadDates();
}
</script>

</body>
</html>
